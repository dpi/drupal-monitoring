<?php
/**
 * @file
 * Contains \MonitoringCoreTest.
 */

/**
 * Cron sensor tests.
 */
class MonitoringCoreTest extends MonitoringTestBase {

  protected $profile = 'testing';

  static function getInfo() {
    return array(
      'name' => 'Monitoring Drupal core',
      'description' => 'Drupal core sensors tests.',
      'group' => 'Monitoring',
    );
  }

  /**
   * {@inheritdoc}
   */
  function setUp() {
    parent::setUp(array('dblog', 'image', 'taxonomy'));
  }

  /**
   * Tests individual sensors.
   */
  function testSensors() {

    // ======= SensorLastCronRun tests ======= //

    $time_shift = (60 * 60 * 24 + 1);
    variable_set('cron_last', REQUEST_TIME - $time_shift);
    $result = $this->runSensor('last_cron_run');
    $this->assertTrue($result->isWarning());
    $this->assertEqual($result->getSensorValue(), $time_shift);

    $time_shift = (60 * 60 * 24 * 3 + 1);
    variable_set('cron_last', REQUEST_TIME - $time_shift);
    $result = $this->runSensor('last_cron_run');
    $this->assertTrue($result->isCritical());
    $this->assertEqual($result->getSensorValue(), $time_shift);

    drupal_cron_run();

    $result = $this->runSensor('last_cron_run');
    $this->assertTrue($result->isOk());
    $this->assertEqual($result->getSensorValue(), 0);

    // ======= Cron safe threshold (poormanscron) tests ======= //

    $result = $this->runSensor('cron_safe_threshold_enabled');
    $this->assertTrue($result->isCritical());
    variable_set('cron_safe_threshold', '0');
    $result = $this->runSensor('cron_safe_threshold_enabled');
    $this->assertTrue($result->isOk());

    // ======= SensorQueue tests ======= //

    /** @var DrupalQueueInterface $queue */
    $queue = DrupalQueue::get('monitoring_test');
    $queue->createItem(array());
    $queue->createItem(array());
    $result = $this->runSensor('queue_monitoring_test');
    $this->assertEqual($result->getSensorValue(), 2);

    // ======= SensorDrupalRequirements tests ======= //

    $result = $this->runSensor('drupal_requirements_monitoring_test');
    $this->assertTrue($result->isOk());
    $this->assertEqual($result->getSensorMessage(), 'Requirements check OK');

    // Set basic requirements saying that all is ok.
    $requirements = array(
      'requirement1' => array(
        'title' => 'requirement1',
        'description' => 'requirement1 description',
        'severity' => REQUIREMENT_OK,
      ),
      'requirement_excluded' => array(
        'title' => 'excluded requirement',
        'description' => 'requirement that should be excluded from monitoring by the sensor',
        // Set the severity to ERROR to test if the sensor result is not
        // affected by this requirement.
        'severity' => REQUIREMENT_ERROR,
      ),
    );
    variable_set('monitoring_test_requirements', $requirements);

    // Set requirements exclude keys into the sensor settings.
    $settings = monitoring_sensor_settings_get('drupal_requirements_monitoring_test');
    $settings['exclude keys'] = array('requirement_excluded');
    monitoring_sensor_settings_save('drupal_requirements_monitoring_test', $settings);

    // We still should have OK status but with different message
    $result = $this->runSensor('drupal_requirements_monitoring_test');
    // We expect OK status as REQUIREMENT_ERROR is set by excluded requirement.
    $this->assertTrue($result->isOk());
    $this->assertEqual($result->getSensorMessage(), 'requirement1, requirement1 description');

    // Add warning state.
    $requirements['requirement2'] = array(
      'title' => 'requirement2',
      'description' => 'requirement2 description',
      'severity' => REQUIREMENT_WARNING,
    );
    variable_set('monitoring_test_requirements', $requirements);

    // Now the sensor should have escalated to the requirement in warning state.
    $result = $this->runSensor('drupal_requirements_monitoring_test');
    $this->assertTrue($result->isWarning());
    $this->assertEqual($result->getSensorMessage(), 'requirement2, requirement2 description');

    // Add error state.
    $requirements['requirement3'] = array(
      'title' => 'requirement3',
      'description' => 'requirement3 description',
      'severity' => REQUIREMENT_ERROR,
    );
    variable_set('monitoring_test_requirements', $requirements);

    // Now the sensor should have escalated to the requirement in critical state.
    $result = $this->runSensor('drupal_requirements_monitoring_test');
    $this->assertTrue($result->isCritical());
    $this->assertEqual($result->getSensorMessage(), 'requirement3, requirement3 description');

    // ======= Watchdog 404 in last 24 hours tests ======= //

    watchdog('page not found', 'not/found');
    $result = $this->runSensor('404_in_last_24_hours');
    $this->assertTrue($result->isOk());
    $this->assertEqual($result->getSensorMessage(), '1 watchdog events, not/found');
    $this->assertEqual($result->getSensorValue(), 1);

    for ($i = 1; $i < 20; $i++) {
      watchdog('page not found', 'not/found');
    }

    $result = monitoring_sensor_run('404_in_last_24_hours', TRUE);
    $this->assertEqual($result->getSensorValue(), 20);
    $this->assertTrue($result->isWarning());

    for ($i = 0; $i < 100; $i++) {
      watchdog('page not found', 'not/found/another');
    }

    $result = monitoring_sensor_run('404_in_last_24_hours', TRUE);
    $this->assertEqual($result->getSensorValue(), 100);
    $this->assertTrue($result->isCritical());

    // ======= SensorWatchdogMissingImageStyle tests ======= //

    for ($i = 0; $i < 5; $i++) {
      watchdog('image', 'Source image at %source_image_path not found while trying to generate derivative image at %derivative_path.',
        array(
          '%source_image_path' => 'public://portrait-pictures/redmouse.jpeg',
          '%derivative_path' => 'hash://styles/preview/1234.jpeg',
        ));
    }
    watchdog('image', 'Source image at %source_image_path not found while trying to generate derivative image at %derivative_path.',
      array(
        '%source_image_path' => 'public://portrait-pictures/bluemouse.jpeg',
        '%derivative_path' => 'hash://styles/preview/5678.jpeg',
      ));

    $result = $this->runSensor('image_style_missing_count');
    $this->assertEqual(5, $result->getSensorValue());
    $this->assertTrue(strpos($result->getSensorMessage(), 'public://portrait-pictures/redmouse.jpeg') !== FALSE);
    $this->assertTrue($result->isWarning());

    // ======= Watchdog sensor tests ======= //

    // Create watchdog entry with severity alert.
    watchdog('test', 'test message', array(), WATCHDOG_ALERT);

    // Run sensor and test the output.
    $result = $this->runSensor('watchdog_severity_' . WATCHDOG_ALERT);
    $this->assertEqual($result->getSensorValue(), 1);

    // ======= SensorFailedUserLogins tests ======= //

    watchdog('user', 'Login attempt failed for %user.', array('%user' => 'user1'), WATCHDOG_NOTICE);
    watchdog('user', 'Login attempt failed for %user.', array('%user' => 'user1'), WATCHDOG_NOTICE);
    watchdog('user', 'Login attempt failed for %user.', array('%user' => 'user2'), WATCHDOG_NOTICE);

    $result = $this->runSensor('failed_user_logins');
    $this->assertEqual($result->getSensorValue(), 3);
    $this->assertTrue(strpos($result->getSensorMessage(), 'user1: 2') !== FALSE);
    $this->assertTrue(strpos($result->getSensorMessage(), 'user2: 1') !== FALSE);

    // ======= SensorGitDirtyTree tests ======= //

    // Enable the sensor and set cmd to output something
    monitoring_sensor_settings_save('git_dirty_tree', array(
      'enabled' => TRUE,
      'cmd' => 'echo "dummy output\nanother dummy output"',
    ));
    $verbose = array();
    $result = monitoring_sensor_run('git_dirty_tree', TRUE, $verbose);
    $this->assertTrue($result->isCritical());
    // The verbose output should contain the cmd output.
    $this->assertTrue(strpos(serialize($verbose), 'dummy output') !== FALSE);
    // Two lines of cmd output.
    $this->assertEqual($result->getSensorValue(), 2);

    // Now echo empty string
    monitoring_sensor_settings_save('git_dirty_tree', array(
      'enabled' => TRUE,
      'cmd' => 'echo ""',
    ));
    $result = monitoring_sensor_run('git_dirty_tree', TRUE);
    $this->assertTrue($result->isOk());
    // The message should say that it is ok.
    $this->assertTrue(strpos($result->getSensorMessage(), 'Git repository clean') !== FALSE);

  }

  /**
   * Tests the watchdog entries aggregator.
   */
  function testGenericDBAggregate() {

    // Aggregate by watchdog type.
    monitoring_sensor_settings_save('watchdog_aggregate_test', array(
      'conditions' => array(
        array('field' => 'type', 'value' => 'test_type'),
      ),
    ));
    watchdog('test_type', $this->randomName());
    watchdog('test_type', $this->randomName());
    watchdog('other_test_type', $this->randomName());
    $result = $this->runSensor('watchdog_aggregate_test');
    $this->assertEqual($result->getSensorValue(), 2);

    // Aggregate by watchdog message.
    monitoring_sensor_settings_save('watchdog_aggregate_test', array(
      'conditions' => array(
        array('field' => 'message', 'value' => 'test_message'),
      )
    ));
    watchdog($this->randomName(), 'test_message');
    watchdog($this->randomName(), 'another_test_message');
    watchdog($this->randomName(), 'another_test_message');
    $result = $this->runSensor('watchdog_aggregate_test');
    $this->assertEqual($result->getSensorValue(), 1);

    // Aggregate by watchdog severity.
    monitoring_sensor_settings_save('watchdog_aggregate_test', array(
      'conditions' => array(
        array('field' => 'severity', 'value' => WATCHDOG_CRITICAL),
      )
    ));
    watchdog($this->randomName(), $this->randomName(), array(), WATCHDOG_CRITICAL);
    watchdog($this->randomName(), $this->randomName(), array(), WATCHDOG_CRITICAL);
    watchdog($this->randomName(), $this->randomName(), array(), WATCHDOG_CRITICAL);
    watchdog($this->randomName(), $this->randomName(), array(), WATCHDOG_CRITICAL);
    $result = $this->runSensor('watchdog_aggregate_test');
    $this->assertEqual($result->getSensorValue(), 4);

    // Aggregate by watchdog location.
    monitoring_sensor_settings_save('watchdog_aggregate_test', array(
      'conditions' => array(
        array('field' => 'location', 'value' => 'http://some.url.dev'),
      )
    ));
    // Update the two test_type watchdog entries with a custom location.
    db_update('watchdog')
      ->fields(array('location' => 'http://some.url.dev'))
      ->condition('type', 'test_type')
      ->execute();
    $result = $this->runSensor('watchdog_aggregate_test');
    $this->assertEqual($result->getSensorValue(), 2);

    // Filter for time period.
    monitoring_sensor_settings_save('watchdog_aggregate_test', array(
      'time_period' => array('field' => 'timestamp', 'value' => 10),
    ));

    // Make all system watchdog messages older than the configured time period.
    db_update('watchdog')
      ->fields(array('timestamp' => REQUEST_TIME - 20))
      ->condition('type', 'system')
      ->execute();
    $count_latest = db_query('SELECT COUNT(*) FROM {watchdog} WHERE timestamp > :timestamp', array(':timestamp' => REQUEST_TIME - 10))->fetchField();
    $result = $this->runSensor('watchdog_aggregate_test');
    $this->assertEqual($result->getSensorValue(), $count_latest);

    // Test for thresholds and statuses.
    monitoring_sensor_settings_save('watchdog_aggregate_test', array(
      'conditions' => array(
        array('field' => 'type', 'value' => 'test_watchdog_aggregate_sensor'),
      )
    ));
    $result = $this->runSensor('watchdog_aggregate_test');
    $this->assertTrue($result->isOk());
    $this->assertEqual($result->getSensorValue(), 0);

    watchdog('test_watchdog_aggregate_sensor', 'testing');
    $result = $this->runSensor('watchdog_aggregate_test');
    $this->assertTrue($result->isWarning());
    $this->assertEqual($result->getSensorValue(), 1);

    watchdog('test_watchdog_aggregate_sensor', 'testing');
    $result = $this->runSensor('watchdog_aggregate_test');
    $this->assertTrue($result->isCritical());
    $this->assertEqual($result->getSensorValue(), 2);

    // Test with different db table.
    $info = monitoring_sensor_info_instance('db_aggregate_test');
    $time_period = $info->getSetting('time_period');
    $this->drupalCreateNode(array('promote' => '1'));
    $this->drupalCreateNode(array('promote' => '0'));
    $this->drupalCreateNode(array('promote' => '0'));
    // Create one node that should not meet the time_period condition.
    $node = $this->drupalCreateNode(array('promote' => '0'));
    db_update('node')
      ->fields(array('created' => REQUEST_TIME - ($time_period['value'] + 10)))
      ->condition('nid', $node->nid)
      ->execute();

    // Based on default sensor settings we should get the promoted node.
    $result = $this->runSensor('db_aggregate_test');
    $this->assertEqual($result->getSensorValue(), 1);

    // Test with settings updated.
    $settings = monitoring_sensor_settings_get('db_aggregate_test');
    $settings['conditions'] = array(
      array('field' => 'promote', 'value' => '0'),
    );
    monitoring_sensor_settings_save('db_aggregate_test', $settings);
    $result = $this->runSensor('db_aggregate_test');
    // There should be two nodes with promote 0 and created in last 24 hours.
    $this->assertEqual($result->getSensorValue(), 2);

    // Test support for configurable fields, create a taxonomy reference field.
    $type = $this->drupalCreateContentType();

    $vocabulary = $this->createVocabulary();

    $field = array(
      'field_name' => 'term_reference',
      'type' => 'taxonomy_term_reference',
      'cardinality' => FIELD_CARDINALITY_UNLIMITED,
      'settings' => array(
        'allowed_values' => array(
          array(
            'vocabulary' => $vocabulary->machine_name,
            'parent' => 0,
          ),
        ),
      ),
    );
    field_create_field($field);

    // Create a second field.
    $instance = array(
      'field_name' => 'term_reference',
      'bundle' => $type->type,
      'entity_type' => 'node',
      'widget' => array(
        'type' => 'options_select',
      ),
      'display' => array(
        'default' => array(
          'type' => 'taxonomy_term_reference_link',
        ),
      ),
    );
    field_create_instance($instance);

    $field = array(
      'field_name' => 'term_reference2',
      'type' => 'taxonomy_term_reference',
      'cardinality' => FIELD_CARDINALITY_UNLIMITED,
      'settings' => array(
        'allowed_values' => array(
          array(
            'vocabulary' => $vocabulary->machine_name,
            'parent' => 0,
          ),
        ),
      ),
    );
    field_create_field($field);

    $instance = array(
      'field_name' => 'term_reference2',
      'bundle' => $type->type,
      'entity_type' => 'node',
      'widget' => array(
        'type' => 'options_select',
      ),
      'display' => array(
        'default' => array(
          'type' => 'taxonomy_term_reference_link',
        ),
      ),
    );
    field_create_instance($instance);

    // Create some terms.
    $term1 = $this->createTerm($vocabulary);
    $term2 = $this->createTerm($vocabulary);

    // Create node that only references the first term.
    $node1 = $this->drupalCreateNode(array(
      'created' => REQUEST_TIME,
      'type' => $type->type,
      'term_reference' => array(
        LANGUAGE_NONE => array(
          array('tid' => $term1->tid),
        ),
      ),
    ));

    // Create node that only references both terms.
    $node2 = $this->drupalCreateNode(array(
      'created' => REQUEST_TIME,
      'type' => $type->type,
      'term_reference' => array(
        LANGUAGE_NONE => array(
          array('tid' => $term1->tid),
          array('tid' => $term2->tid),
        ),
      ),
    ));

    // Create a third node that references both terms but in different fields.
    $node2 = $this->drupalCreateNode(array(
      'created' => REQUEST_TIME,
      'type' => $type->type,
      'term_reference' => array(
        LANGUAGE_NONE => array(
          array('tid' => $term1->tid),
        ),
      ),
      'term_reference2' => array(
        LANGUAGE_NONE => array(
          array('tid' => $term2->tid),
        ),
      ),
    ));

    // Update the sensor to look for nodes with a reference to term1 in the
    // first field.
    $settings = monitoring_sensor_settings_get('db_aggregate_test');
    $settings['conditions'] = array(
      array('field' => 'term_reference.tid', 'value' => $term1->tid),
    );
    monitoring_sensor_settings_save('db_aggregate_test', $settings);
    $result = $this->runSensor('db_aggregate_test');
    // There should be three nodes with that reference.
    $this->assertEqual($result->getSensorValue(), 3);

    // Update the sensor to look for nodes with a reference to term1 in the
    // first field and term2 in the second.
    $settings = monitoring_sensor_settings_get('db_aggregate_test');
    $settings['conditions'] = array(
      array('field' => 'term_reference.tid', 'value' => $term1->tid),
      array('field' => 'term_reference2.tid', 'value' => $term2->tid),
    );
    monitoring_sensor_settings_save('db_aggregate_test', $settings);
    $result = $this->runSensor('db_aggregate_test');
    // There should be one nodes with those references.
    $this->assertEqual($result->getSensorValue(), 1);
  }

  /**
   * Returns a new vocabulary with random properties.
   *
   * @return object
   *   Vocabulary object.
   */
  function createVocabulary() {
    // Create a vocabulary.
    $vocabulary = new stdClass();
    $vocabulary->name = $this->randomName();
    $vocabulary->description = $this->randomName();
    $vocabulary->machine_name = drupal_strtolower($this->randomName());
    $vocabulary->help = '';
    $vocabulary->weight = mt_rand(0, 10);
    taxonomy_vocabulary_save($vocabulary);
    return $vocabulary;
  }

  /**
   * Returns a new term with random properties in vocabulary $vid.
   *
   * @return object
   *   Term object.
   */
  function createTerm($vocabulary) {
    $term = new stdClass();
    $term->name = $this->randomName();
    $term->description = $this->randomName();
    // Use the first available text format.
    $term->format = db_query_range('SELECT format FROM {filter_format}', 0, 1)->fetchField();
    $term->vid = $vocabulary->vid;
    taxonomy_term_save($term);
    return $term;
  }

}
